package ru.ztrap.iconics

import com.mikepenz.iconics.typeface.ITypeface

import java.io.File
import java.util.Date
import java.util.regex.Pattern

import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.parsers.ParserConfigurationException
import javax.xml.transform.OutputKeys
import javax.xml.transform.TransformerException
import javax.xml.transform.TransformerFactory
import javax.xml.transform.dom.DOMSource
import javax.xml.transform.stream.StreamResult

/**
 * @author pa.gulko zTrap (29.03.2018)
 */
abstract class IconicsStringGenerator {

    companion object {
        val UPPERCASE_PATTERN: Pattern = Pattern.compile("(?=\\p{Lu})")
        const val WORD_DELIMITER = "_"
        const val XML = "xml"
    }

    protected enum class FileCreationStrategy {
        SAVE_OLD, SAVE_ONLY_CURRENT
    }

    /** Define resolution strategy for new versions */
    protected abstract val fileCreationStrategy: FileCreationStrategy

    /** @return modifier for mark file as current-version file */
    protected open val modifierCurrent: String get() = "_current_"

    /** @return directory path for generated .xml file */
    protected open val outputDirectory: String
        get() = "src${File.separator}main${File.separator}res${File.separator}values"

    /** Magic live here */
    @Throws(ParserConfigurationException::class, TransformerException::class)
    protected open fun generateIconsFrom(typeface: ITypeface) {

        val handledClassName = handleWords(typeface.fontName) + "_v"
        val fileName = handledClassName + typeface.version + "." + XML
        val fontDirectory = File(outputDirectory)

        val doc = DocumentBuilderFactory.newInstance()
                .newDocumentBuilder()
                .newDocument()

        val resources = doc.createElement("resources")
        val comment1 = doc.createComment(
                " Generated by Android-Iconics String Generator v"
                        + BuildConfig.VERSION_NAME
                        + " at "
                        + Date()
                        + " "
        )
        val comment2 = doc.createComment(" https://github.com/zTrap/Android-Iconics-String-Generator ")

        doc.appendChild(resources)
        resources.appendChild(comment1)
        resources.appendChild(comment2)

        typeface.icons.forEach {
            doc.createElement("string")
                    .apply {
                        setAttribute("name", it)
                        setAttribute("translatable", "false")
                        textContent = it
                    }
                    .let { resources.appendChild(it) }

        }

        val newFile = File(fontDirectory, "$modifierCurrent$fileName")

        if (newFile.exists()) {
            // replace file's content with same version
            newFile.delete()
        }

        /** search actual file with leading [modifierCurrent] */
        val files = fontDirectory.listFiles { file ->
            file.name.matches(("$modifierCurrent$handledClassName.+\\.$XML").toRegex())
        }

        if (files != null && files.isNotEmpty()) {
            val current = files.first()
            when (fileCreationStrategy) {
                FileCreationStrategy.SAVE_OLD -> {
                    val renamed = File(fontDirectory, current.name.removePrefix(modifierCurrent))
                    if (!current.renameTo(renamed)) {
                        throwCantRenameFileException(renamed, current)
                    }
                }
                FileCreationStrategy.SAVE_ONLY_CURRENT -> current.delete()
            }
        }

        TransformerFactory.newInstance().newTransformer().apply {
            setOutputProperty(OutputKeys.ENCODING, "UTF-8")
            setOutputProperty(OutputKeys.INDENT, "yes")
            setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4")
            transform(DOMSource(doc), StreamResult(newFile))
        }
    }

    protected open fun handleWords(fieldName: String): String {
        val clearedFieldName = fieldName.replace(" ", "")
        return buildString {
            UPPERCASE_PATTERN.split(clearedFieldName).forEach { word ->
                if (isNotEmpty()) append(WORD_DELIMITER)
                append(word.toLowerCase())
            }
        }
    }

    private fun throwCantRenameFileException(renamed: File, current: File) {
        val message = buildString {
            "Unable to rename file from ${current.name} to ${renamed.name}."
            if (renamed.exists()) " File ${renamed.name} is already exist."
        }

        if (renamed.exists()) {
            throw FileAlreadyExistsException(renamed, reason = message)
        } else {
            throw IllegalArgumentException(message)
        }
    }
}
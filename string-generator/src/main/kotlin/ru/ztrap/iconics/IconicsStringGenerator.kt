package ru.ztrap.iconics

import com.mikepenz.iconics.typeface.ITypeface
import ru.ztrap.iconics.IconicsStringGenerator.FileCreationStrategy.SAVE_OLD
import ru.ztrap.iconics.IconicsStringGenerator.FileCreationStrategy.SAVE_ONLY_CURRENT

import java.io.File
import java.util.*

import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.parsers.ParserConfigurationException
import javax.xml.transform.OutputKeys
import javax.xml.transform.TransformerException
import javax.xml.transform.TransformerFactory
import javax.xml.transform.dom.DOMSource
import javax.xml.transform.stream.StreamResult

/**
 * @author pa.gulko zTrap (29.03.2018)
 */
abstract class IconicsStringGenerator {

    /** kotlin companion object */
    companion object {

        /** File writer from DOM parser */
        @get:Synchronized internal val TRANSFORMER by lazy {
            TransformerFactory.newInstance().newTransformer().apply {
                setOutputProperty(OutputKeys.ENCODING, "UTF-8")
                setOutputProperty(OutputKeys.INDENT, "yes")
                setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4")
            }
        }

        /** Pattern to detect words in font name */
        @JvmField val UPPERCASE_PATTERN: Regex = "(?=\\p{Lu})".toRegex()
        /** Delimiter for words in out file name */
        const val WORD_DELIMITER = "_"
        /** File extension */
        const val XML = "xml"
    }

    /** Strategy of file with strings creation */
    protected enum class FileCreationStrategy {
        /**
         * Strategy to save old versions of strings file which will rename file with leading
         * [modifierCurrent] and comment all string fields inside
         */
        SAVE_OLD,
        /** Strategy to remove file with old version */
        SAVE_ONLY_CURRENT
    }

    /** Define resolution strategy for new versions */
    protected abstract val fileCreationStrategy: FileCreationStrategy

    /** @return modifier for mark file as current-version file */
    protected open val modifierCurrent: String
        get() = "_current_"

    /** @return modifier for mark file as old-version file */
    protected open val modifierOld: String
        get() = "_old_"

    /** @return directory path for generated .xml file */
    protected open val outputDirectory: String
        get() = "src${File.separator}main${File.separator}res${File.separator}values"

    /** Magic lives here */
    protected fun ITypeface.generateIcons() {
        generateIconsFrom(this)
    }

    /** Magic lives here */
    @Throws(ParserConfigurationException::class, TransformerException::class)
    protected open fun generateIconsFrom(typeface: ITypeface) {

        val handledClassName = handleWords(typeface.fontName) + "_v"
        val fileName = "$handledClassName${typeface.version}.$XML"
        val fontDirectory = File(outputDirectory)

        val doc = DocumentBuilderFactory.newInstance()
                .newDocumentBuilder()
                .newDocument()

        val resources = doc.createElement("resources")
        val comment1 = doc.createComment(
                " Generated by Android-Iconics String Generator "
                        + "v${BuildConfig.VERSION_NAME} "
                        + "at ${Date()} "
        )
        val comment2 = doc.createComment(" https://github.com/zTrap/Android-Iconics-String-Generator ")

        doc.appendChild(resources)
        resources.appendChild(comment1)
        resources.appendChild(comment2)

        typeface.icons.forEach {
            doc.createElement("string").apply {
                setAttribute("name", it)
                setAttribute("translatable", "false")
                textContent = it
                resources.appendChild(this)
            }
        }

        val newFile = File(fontDirectory, "$modifierCurrent$fileName")

        if (newFile.exists()) {
            // Replace file's content with the same version
            newFile.delete()
        }

        /** Search actual file with leading [modifierCurrent] */
        val files = fontDirectory.listFiles { file ->
            file.name.matches(("$modifierCurrent$handledClassName.+\\.$XML").toRegex())
        }

        if (files?.isNotEmpty() == true) {
            val old = files.first()
            when (fileCreationStrategy) {
                SAVE_OLD -> renameOld(fontDirectory, old)
                SAVE_ONLY_CURRENT -> old.delete()
            }
        }

        TRANSFORMER.transform(DOMSource(doc), StreamResult(newFile))
    }

    /** To lower_snake_case words handler */
    protected open fun handleWords(fontName: String): String {
        val clearedFieldName = fontName.replace(" ", "")
        return UPPERCASE_PATTERN.split(clearedFieldName).joinToString(WORD_DELIMITER) {
            it.toLowerCase(Locale.getDefault())
        }
    }

    private fun renameOld(fontDirectory: File, old: File) {
        val mapped = old.readText()
                .lineSequence()
                .filterNot { it.isBlank() }
                .joinToString("\n") {
                    if (it.trim().startsWith("<string")) {
                        "    <!-- ${it.trim()} -->"
                    } else {
                        it
                    }
                }

        val renamed = File(fontDirectory, modifierOld + old.name.removePrefix(modifierCurrent))
        if (!old.renameTo(renamed)) {
            throwCantRenameFileException(renamed, old)
        }

        renamed.writeText(mapped)
    }

    private fun throwCantRenameFileException(renamed: File, current: File) {
        val message = buildString {
            append("Unable to rename file from ${current.name} to ${renamed.name}.")
            if (renamed.exists()) {
                append(" File ${renamed.name} is already exist.")
            }
        }

        if (renamed.exists()) {
            throw FileAlreadyExistsException(renamed, reason = message)
        } else {
            throw IllegalArgumentException(message)
        }
    }
}